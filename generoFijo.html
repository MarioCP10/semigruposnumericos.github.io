<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SN de g√©nero fijo</title>
    <link rel="stylesheet" type="text/css" href="generoFijo.css" />
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
        </script>
    <script>
        //caches para memoizaci√≥n para mejorar la eficiencia
        let cacheGenero = {};
        let cacheFrobenius = {};

        /**
         * @function mcd
         * @description Calcula el m√°ximo com√∫n divisor (MCD) de dos n√∫meros usando Euclides.
         * @param {number} a ‚Äì Primer operando (mayor o igual a 0)
         * @param {number} b ‚Äì Segundo operando (mayor o igual a 0)
         * @returns {number} ‚Äì El MCD de a y b.
         */
        function mcd(a, b) {
            while (b !== 0) {
                a %= b;
                let temp = a;
                a = b;
                b = temp;
            }
            return a;
        }

        /**
         * @function clave
         * @description Genera una clave √∫nica para un array S ordenado y con comas.
         * @param {number[]} S ‚Äì Conjunto de generadores.
         * @returns {string} ‚Äì Cadena "s1,s2,‚Ä¶,".
         */
        function clave(S) {
            let copia = S.slice();
            copia.sort((a, b) => a - b);
            return copia.join(",") + ",";
        }

        /**
         * @function calcularConductor
         * @description Encuentra el conductor de ‚ü®S‚ü© buscando un bloque de min(S) consecutivos.
         * @param {number[]} S ‚Äì Conjunto de generadores.
         * @returns {number} ‚Äì El conductor n tal que todos aquellos elementos mayores o iguales a n est√°n en ‚ü®S‚ü©.
         */
        function calcularConductor(S) {
            let minS = Math.min(...S);
            let max_val = S.reduce((acc, cur) => acc + cur, 0);
            let alcanzable = [];
            let encontradoBloqueConsecutivo = false;
            let consecutivosNecesarios = minS;
            let conductor = max_val;
            while (!encontradoBloqueConsecutivo) {
                alcanzable = new Array(max_val + 1).fill(false);
                alcanzable[0] = true;
                for (let s of S) {
                    for (let i = s; i <= max_val; i++) {
                        alcanzable[i] = alcanzable[i] || alcanzable[i - s];
                    }
                }
                let consecutivos = 0;
                for (let i = 0; i <= max_val; i++) {
                    consecutivos = alcanzable[i] ? consecutivos + 1 : 0;
                    if (consecutivos >= consecutivosNecesarios) {
                        conductor = i - consecutivosNecesarios + 1;
                        encontradoBloqueConsecutivo = true;
                        break;
                    }
                }
                if (!encontradoBloqueConsecutivo) {
                    max_val *= 2;
                }
            }
            return conductor;
        }

        /**
         * @function calcularGenero
         * @description Cuenta huecos (< conductor) en ‚ü®S‚ü© para hallar el g√©nero.
         * @param {number[]} S ‚Äì Conjunto de generadores.
         * @returns {number} ‚Äì N√∫mero de enteros no alcanzables (g√©nero).
         */
        function calcularGenero(S) {
            let k = clave(S);
            if (cacheGenero.hasOwnProperty(k)) {
                return cacheGenero[k];
            }

            let minS = Math.min(...S);
            let max_val = S.reduce((acc, cur) => acc + cur, 0);
            let alcanzable = [];
            let encontradoBloqueConsecutivo = false;
            let consecutivosNecesarios = minS;
            let genero = 0;
            while (!encontradoBloqueConsecutivo) {
                alcanzable = new Array(max_val + 1).fill(false);
                alcanzable[0] = true;
                for (let s of S) {
                    for (let i = s; i <= max_val; i++) {
                        alcanzable[i] = alcanzable[i] || alcanzable[i - s];
                    }
                }
                let consecutivos = 0;
                for (let i = 0; i <= max_val; i++) {
                    consecutivos = alcanzable[i] ? consecutivos + 1 : 0;
                    if (consecutivos >= consecutivosNecesarios) {
                        encontradoBloqueConsecutivo = true;
                        break;
                    }
                }
                if (!encontradoBloqueConsecutivo) {
                    max_val *= 2;
                }
            }

            //Se usa el conductor para contar los huecos
            let conductor = 0;
            {
                let consecutivos = 0;
                for (let i = 0; i <= max_val; i++) {
                    consecutivos = alcanzable[i] ? consecutivos + 1 : 0;
                    if (consecutivos >= consecutivosNecesarios) {
                        conductor = i - consecutivosNecesarios + 1;
                        break;
                    }
                }
            }
            for (let i = 0; i < conductor; i++) {
                if (!alcanzable[i])
                    genero++;
            }
            cacheGenero[k] = genero;
            return genero;
        }

        /**
         * @function calcularFrobenius
         * @description Encuentra el mayor entero no alcanzable en ‚ü®S‚ü©.
         * @param {number[]} S ‚Äì Conjunto de generadores.
         * @returns {number} ‚Äì N√∫mero de Frobenius o -1 si S = <1>.
         */
        function calcularFrobenius(S) {
            let k = clave(S);
            if (cacheFrobenius.hasOwnProperty(k)) {
                return cacheFrobenius[k];
            }
            let max_val = S.reduce((acc, cur) => acc + cur, 0);
            let alcanzable = new Array(max_val + 1).fill(false);
            alcanzable[0] = true;
            for (let s of S) {
                for (let i = s; i <= max_val; i++) {
                    alcanzable[i] = alcanzable[i] || alcanzable[i - s];
                }
            }
            for (let i = max_val; i >= 0; i--) {
                if (!alcanzable[i]) {
                    cacheFrobenius[k] = i;
                    return i;
                }
            }
            cacheFrobenius[k] = -1;
            return -1;
        }

        /**
         * @function esMinimalHilbert
         * @description Verifica minimalidad de Hilbert de S.
         * @param {number[]} S ‚Äì Conjunto de generadores.
         * @returns {boolean} ‚Äì True si minimal; false en caso contrario.
         */
        function esMinimalHilbert(S) {
            if (S.length === 1) return true;
            let minS = Math.min(...S);
            let conductor = calcularConductor(S);
            let limit = conductor + minS;

            //Se genera la expansi√≥n de Hilbert
            let hilbert = new Set();
            let cola = [0];
            hilbert.add(0);
            while (cola.length > 0) {
                let t = cola.pop();
                for (let a of S) {
                    let nuevoTermino = t + a;
                    if (nuevoTermino <= limit && !hilbert.has(nuevoTermino)) {
                        hilbert.add(nuevoTermino);
                        cola.push(nuevoTermino);
                    }
                }
            }

            //Se comprueban los consecutivos
            let consecutivos = 0;
            let prev = -2;
            let ordenadoHilbert = Array.from(hilbert).sort((a, b) => a - b);
            for (let n of ordenadoHilbert) {
                consecutivos = (n === prev + 1) ? consecutivos + 1 : 1;
                if (consecutivos >= minS) break;
                prev = n;
            }
            if (consecutivos < minS) return false;

            //Se verifica que ning√∫n elemento de S se pueda generar sin √©l mismo
            for (let i = 0; i < S.length; i++) {
                let copia = S.slice();
                copia.splice(i, 1);
                let forma = new Set();
                let cola = [0];
                forma.add(0);
                let lim = S[i] + 1;
                while (cola.length > 0) {
                    let t = cola.pop();
                    for (let a of copia) {
                        let nuevo = t + a;
                        if (nuevo <= lim && !forma.has(nuevo)) {
                            forma.add(nuevo);
                            cola.push(nuevo);
                        }
                    }
                }
                if (forma.has(S[i])) return false;
            }

            //Se verificar que todos los elementos generadores est√°n en la expansi√≥n
            for (let s of S) {
                if (!hilbert.has(s)) return false;
            }
            return true;
        }

        /**
         * @function esHoja
         * @description Determina si S es hoja para el g√©nero dado.
         * @param {number[]} S ‚Äì Conjunto de generadores.
         * @param {number} genero ‚Äì G√©nero dado.
         * @returns {boolean}
         */
        function esHoja(S, genero) {
            if (calcularGenero(S) !== genero) return false;
            let f = calcularFrobenius(S);
            if (f === -1) return false;
            let max_elem = Math.max(...S);
            return f > max_elem;
        }

        /**
         * @function mcdEsUno
         * @description Comprueba mcd(S)=1.
         * @param {number[]} S ‚Äì Conjunto de generadores.
         * @returns {boolean}
         */
        function mcdEsUno(S) {
            if (S.length === 0) return false;
            let m = S[0];
            for (let i = 1; i < S.length; i++) {
                m = mcd(m, S[i]);
                if (m === 1) return true;
            }
            return m === 1;
        }

        /**
         * @function generarCombinaciones
         * @description Genera todas las combinaciones posibles de un conjunto dado con un tama√±o fijo usando backtracking.
         * @param {Array<Array<number>>} subconjuntos - Array donde se almacenan las combinaciones generadas.
         * @param {Array<number>} combinacion - Combinaci√≥n parcial actual en construcci√≥n.
         * @param {Array<number>} numeros - Conjunto de n√∫meros disponibles para combinar.
         * @param {number} inicio - √çndice de inicio para el recorrido de n√∫meros.
         * @param {number} tamano - Tama√±o de las combinaciones.
         */
        function generarCombinaciones(subconjuntos, combinacion, numeros, inicio, tamano) {
            if (combinacion.length === tamano) {
                subconjuntos.push(combinacion.slice());
                return;
            }
            for (let i = inicio; i < numeros.length; i++) {
                combinacion.push(numeros[i]);
                generarCombinaciones(subconjuntos, combinacion, numeros, i + 1, tamano);
                combinacion.pop();
            }
        }

        /**
         * @function comparaCantidades
         * @description Compara la cantidad de semigrupos num√©ricos internos y hojas.
         * @param {Array<Array<number>>} internos - Lista de semigrupos num√©ricos internos.
         * @param {Array<Array<number>>} hojas - Lista de semigrupos num√©ricos hoja.
         * @returns {string} Mensaje indicando cu√°l grupo tiene mayor cantidad o si son iguales.
         */
        function comparaCantidades(internos, hojas) {
            let mensaje = "";
            if (internos.length > hojas.length)
                mensaje = "Hay m√°s semigrupos num√©ricos internos que hojas.";
            else if (internos.length < hojas.length)
                mensaje = "Hay m√°s semigrupos num√©ricos hojas que internos.";
            else
                mensaje = "Hay igual cantidad de semigrupos num√©ricos internos y hojas.";
            return mensaje;
        }

        /**
         * @function encontrarSemigruposYHojas
         * @description Busca semigrupos internos y hojas de g√©nero g.
         * @param {number} genero ‚Äì G√©nero fijo.
         * @returns {string} ‚Äì HTML con listas en notaci√≥n LaTeX y mensaje de comparaci√≥n.
         */
        function encontrarSemigruposYHojas(genero) {
            let internos = [];
            let hojas = [];
            let limite = genero * 5;
            let numeros = [];

            for (let i = 2; i <= limite; i++) {
                numeros.push(i);
            }

            //Se itera sobre tama√±os de combinaci√≥n desde 2 hasta el valor de genero dado
            for (let tamano = 2; tamano <= genero; tamano++) {
                let subconjuntos = [];
                generarCombinaciones(subconjuntos, [], numeros, 0, tamano);
                for (let subconjunto of subconjuntos) {
                    if (!mcdEsUno(subconjunto)) continue;
                    if (calcularGenero(subconjunto) !== genero) continue;
                    if (!esMinimalHilbert(subconjunto)) continue;
                    if (esHoja(subconjunto, genero))
                        hojas.push(subconjunto);
                    else
                        internos.push(subconjunto);
                }
            }

            //Se introduce el √∫ltimo semigrupo de la expansi√≥n para mejorar el tiempo de c√≥mputo
            let semigrupoExtra = [];
            for (let i = genero + 1; i <= 2 * genero + 1; i++) {
                semigrupoExtra.push(i);
            }
            internos.push(semigrupoExtra);

            let resultado = "<h3>Semigrupos num√©ricos internos:</h3>";
            for (let s of internos) {
                resultado += "$$\\langle " + s.join(",\\, ") + " \\rangle$$";
            }
            resultado += "<h3>Semigrupos num√©ricos hoja:</h3>";
            for (let h of hojas) {
                resultado += "$$\\langle " + h.join(",\\, ") + " \\rangle$$";
            }

            resultado += "<h3>Comparaci√≥n:</h3><p>" + comparaCantidades(internos, hojas) + "</p>";
            return resultado;
        }

        /**
         * @function calcular
         * @description Funci√≥n que se activa desde la interfaz. Valida el input del usuario,
         * llama a `encontrarSemigruposYHojas`, calcula el tiempo de ejecuci√≥n y muestra el resultado.
         */
        function calcular() {
            cacheGenero = {};
            cacheFrobenius = {};

            let input = document.getElementById("inputNumeros").value.trim();

            if (!/^\d+$/.test(input)) {
                alert("Por favor, introduce un √∫nico n√∫mero entero no negativo.");
                vaciarResultados()
                return;
            }

            let genero = parseInt(input);

            if (genero < 0) {
                alert("Por favor, introduce un n√∫mero que sea 0 o mayor.");
                vaciarResultados()
                return;
            }

            let inicio = performance.now();
            let resultado = encontrarSemigruposYHojas(genero);
            let fin = performance.now();

            let tiempo = ((fin - inicio) / 1000).toFixed(2);

            document.getElementById("generoFijo").innerHTML = resultado;
            document.getElementById("tiempoCalculo").innerHTML = tiempo + " s";

            //Se Llama a MathJax para procesar el nuevo contenido matem√°tico
            if (window.MathJax) {
                MathJax.typeset();
            }
        }

        /**
         * @function vaciarResultados
         * @description Limpia los campos de entrada y resultados mostrados en la interfaz.
         */
        function vaciarResultados() {
            document.getElementById("inputNumeros").value = "";
            document.getElementById("generoFijo").innerHTML = "";
            document.getElementById("tiempoCalculo").innerHTML = "";
        }
    </script>
    <script>
        /**
         * @function ejemplos
         * @description Muestra u oculta la secci√≥n de ejemplos.
         */
        function ejemplos() {
            var ejemplosDiv = document.getElementById("ejemplo");
            if (ejemplosDiv.style.display === "none") {
                ejemplosDiv.style.display = "block";
            } else {
                ejemplosDiv.style.display = "none";
            }
        }
    </script>
    <script>
        /**
         * @function propiedades
         * @description Muestra u oculta la secci√≥n de propiedades.
         */
        function propiedades() {
            var propiedadesDiv = document.getElementById("propiedades");
            if (propiedadesDiv.style.display === "none") {
                propiedadesDiv.style.display = "block";
            } else {
                propiedadesDiv.style.display = "none";
            }
        }
    </script>
    <script>
        /**
         * @function utilidades
         * @description Muestra u oculta la secci√≥n de utilidades.
         */
        function utilidades() {
            var utilidadesDiv = document.getElementById("utilidades");
            if (utilidadesDiv.style.display === "none") {
                utilidadesDiv.style.display = "block";
            } else {
                utilidadesDiv.style.display = "none";
            }
        }
    </script>
</head>

<body>
    <header>
        <img id="logo" src="imagenes/logo.png" alt="logo de la pagina del tfg" width="50" height="50">

        <h1 id="SN_principal">SEMIGRUPOS NUM√âRICOS</h1>

        <ul>
            <li><a href="index.html">Inicio</a></li>
            <li><a href="visionmatematica.html">Visi√≥n matem√°tica</a></li>
            <li><a href="visioninformatica.html">Visi√≥n inform√°tica</a></li>
            <li><a href="utilidades.html">Utilidades</a></li>
            <li><a href="informacion.html">Informaci√≥n</a></li>
            <li><a href="experiencias.html">Experiencias</a></li>
        </ul>

    </header>
    <main>
        <section>
            <nav class="sidebar">
                <ul>
                    <li><a href="automatas.html">Automatas</a></li>
                    <li><a href="seguridad.html">Seguridad</a></li>
                    <li><a href="mochila.html">Mochila</a></li>
                    <li><a href="generoFijo.html">G√©nero Fijo</a></li>
                    <li><a href="numeroFrobFijo.html">N√∫mero Frobenius Fijo</a></li>
                    <li><a href="generoMulti.html">G√©nero y Multiplicidad Fijos</a></li>
                </ul>
            </nav>
        </section>

        <section id="sH">
            <h2 id="SH">SEMIGRUPOS NUM√âRICOS DE G√âNERO FIJO</h2>
            <p>
                Dado un conjunto de n√∫meros enteros positivos primos relativos entre s√≠, <span class="form-peque">
                    ùê¥ = {ùëé‚ÇÅ, ùëé‚ÇÇ, ‚Ä¶, ùëé‚Çñ}
                </span>, se define un semigrupo num√©rico como el conjunto formado por todas las combinaciones lineales
                no negativas
                de los elementos de ùê¥, es decir, todos los n√∫meros que pueden expresarse como ùëõ‚ÇÅùëé‚ÇÅ + ùëõ‚ÇÇùëé‚ÇÇ + ‚Ä¶ +
                ùëõ‚Çñùëé‚Çñ, con ùëõ·µ¢
                enteros no negativos. El g√©nero de un semigrupo se corresponde con la cantidad de enteros positivos (los
                huecos) que
                no se pueden obtener de dichas combinaciones, hasta llegar al conductor, que es el primer n√∫mero a
                partir del cual
                todos los enteros son alcanzables. As√≠, estudiar los semigrupos num√©ricos de g√©nero fijo consiste en
                clasificar y
                analizar aquellos semigrupos que presentan un n√∫mero determinado de huecos, lo cual aporta claridad en
                el
                conocimiento de su estructura y en sus aplicaciones en teor√≠a de n√∫meros y problemas algebraicos.
            </p>
            <p id="text">
                Los <strong>semigrupos num√©ricos internos</strong> son aquellos nodos del √°rbol que poseen
                descendientes. En otras palabras, un semigrupo interno es aquel a partir del
                cual es posible obtener al menos un semigrupo de g√©nero <span class="form-peque">\(g+1\)</span> (u otro
                mayor) mediante la eliminaci√≥n
                de uno de sus
                generadores m√≠nimos sin perder la propiedad de ser un semigrupo num√©rico. Estos nodos indican puntos de
                posible
                bifurcaci√≥n en la estructura del √°rbol y suelen tener m√°s de una opci√≥n de extensi√≥n.
            </p>
            <p id="text">
                Por otro lado, los <strong>semigrupos num√©ricos hoja</strong> son aquellos que, adem√°s de cumplir con
                las propiedades de un semigrupo num√©rico, tienen un n√∫mero de Frobenius (el
                mayor entero positivo que no pertenece al semigrupo) que es mayor que el m√°ximo generador del conjunto.
                Esto los
                convierte en semigrupos con una estructura m√°s dispersa, donde los huecos y el conductor juegan un papel
                clave en su
                clasificaci√≥n. Los semigrupos hoja son √∫tiles para explorar configuraciones extremas dentro de un g√©nero
                fijo.
            </p>
            <button onclick="propiedades()">Propiedades</button>
            <div id="propiedades" style="display: none;">
                <p id="text">
                    <span class="punto"></span><strong>Determinaci√≥n √∫nica del g√©nero:</strong> cada semigrupo num√©rico
                    de g√©nero
                    fijo posee un valor √∫nico que indica la cantidad de huecos ‚Äìlos enteros positivos que no pueden
                    expresarse como
                    combinaci√≥n lineal de sus generadores hasta llegar al conductor.
                </p>
                <p id="text">
                    <span class="punto"></span><strong>Presencia de un conductor:</strong> existe un entero, denominado
                    conductor, a
                    partir del cual todos los n√∫meros son alcanzables dentro del semigrupo, evidenciando la densidad de
                    la
                    estructura a partir de ese punto.
                </p>
                <p id="text">
                    <span class="punto"></span><strong>Cierre bajo suma y estabilidad:</strong> al ser cerrados bajo la
                    operaci√≥n
                    suma, estos semigrupos mantienen su estructura algebraica, lo que facilita su an√°lisis y
                    clasificaci√≥n seg√∫n su
                    g√©nero.
                </p>
                <p id="text">
                    <span class="punto"></span><strong>Aplicaci√≥n en problemas de clasificaci√≥n:</strong> la
                    identificaci√≥n y
                    an√°lisis de semigrupos num√©ricos de g√©nero fijo permiten explorar problemas en teor√≠a de n√∫meros y
                    en otros
                    √°mbitos matem√°ticos, estableciendo v√≠nculos con estructuras algebraicas y combinatorias.
                </p>
            </div>
            <button onclick="ejemplos()">Ejemplos</button>
            <div id="ejemplo" style="display: none;">
                <p id="text">
                    <strong>Ejemplo 1 (G√©nero 1):</strong> si el g√©nero fijo es <span class="form-peque">\(1\)</span>,
                    el √∫nico semigrupo interno que
                    hay es
                    <span class="form-peque">\( \langle2,3\rangle \)</span>. En este caso, el √∫nico hueco es <span
                        class="form-peque">\(1\)</span> y, a partir de <span class="form-peque">\(2\)</span>, todas las
                    combinaciones
                    lineales
                    no negativas forman el semigrupo num√©rico.
                </p>
                <p id="text">
                    <strong>Ejemplo 2 (G√©nero 2):</strong> para g√©nero fijo <span class="form-peque">\(2\)</span>, un
                    semigrupo num√©rico interno es
                    <span class="form-peque">\( \langle3,4,5\rangle \)</span>. Aqu√≠, los √∫nicos huecos son <span
                        class="form-peque">\(1\)</span> y <span class="form-peque">\(2\)</span>; a partir de <span
                        class="form-peque">\(3\)</span> se pueden obtener
                    todos los
                    n√∫meros,
                    lo que define el g√©nero como <span class="form-peque">\(2\)</span>.
                </p>
                <p id="text">
                    <strong>Ejemplo 3 (G√©nero 3):</strong> si el g√©nero fijo es <span class="form-peque">\(3\)</span>,
                    el √∫nico semigrupo hoja resultante es
                    <span class="form-peque">\( \langle3,4\rangle \)</span>. Los huecos resultantes son <span
                        class="form-peque">\(\{1,2,5\}\)</span> y el n√∫mero de Frobenius es <span
                        class="form-peque">\(5\)</span>, mayor que
                    el m√°ximo
                    generador <span class="form-peque">\(4\)</span>.
                </p>
                <p id="text">
                    <strong>Ejemplo 4 (G√©nero 4):</strong> un semigrupo hoja para g√©nero fijo <span
                        class="form-peque">\(4\)</span> es
                    <span class="form-peque">\( \langle3,5\rangle \)</span>. En este caso, los huecos son <span
                        class="form-peque">\(\{1,2,4,7\}\)</span> de acuerdo con las combinaciones
                    posibles,
                    estableciendo
                    el g√©nero como <span class="form-peque">\(4\)</span>. Sin embargo, al ser el n√∫mero de Frobenius
                    mayor que todos los elementos del
                    semigrupo (nFrob = <span class="form-peque">\(7\))</span>, se considera hoja.
                </p>
                <p id="text">
                    <strong>Ejemplo 5 (G√©nero 5):</strong> para g√©nero fijo <span class="form-peque">\(5\)</span>, se
                    puede considerar el semigrupo n√∫merico interno
                    <span class="form-peque">\( \langle5,6,7,9\rangle \)</span>. Aqu√≠, tras calcular las combinaciones
                    lineales se
                    obtienen los huecos
                    <span class="form-peque">\(\{1,2,3,4,8\}\)</span>, lo
                    que
                    confirma que el g√©nero es <span class="form-peque">\(5\)</span>.
                </p>
            </div>
            <button onclick="utilidades()">Utilidades</button>
            <div id="utilidades" style="display: none;">
                <p id="text">
                    <span class="punto"></span><strong>Optimizaci√≥n de algoritmos y recursos:</strong>
                    el programa permite explorar estrategias de optimizaci√≥n mediante la identificaci√≥n de semigrupos
                    num√©ricos, lo
                    que facilita la creaci√≥n de algoritmos eficientes para la asignaci√≥n √≥ptima de recursos y la
                    resoluci√≥n de
                    problemas complejos en √°reas como la investigaci√≥n operativa y la programaci√≥n.
                </p>
                <p id="text">
                    <span class="punto"></span><strong>Aplicaciones matem√°ticas avanzadas:</strong>
                    sirve como una herramienta did√°ctica para comprender conceptos fundamentales de la teor√≠a de n√∫meros
                    y
                    combinaciones lineales, apoyando la ense√±anza de semigrupos num√©ricos, programaci√≥n din√°mica y
                    t√©cnicas de
                    optimizaci√≥n.
                </p>
                <p id="text">
                    <span class="punto"></span><strong>Modelado y simulaci√≥n en log√≠stica:</strong>
                    al representar combinaciones de n√∫meros y restricciones, el programa se vuelve √∫til para modelar
                    problemas
                    log√≠sticos reales, como la organizaci√≥n de inventarios o la optimizaci√≥n del empaquetado,
                    permitiendo simular
                    escenarios y optimizar procesos.
                </p>
                <p id="text">
                    <span class="punto"></span><strong>An√°lisis en inform√°tica y teor√≠a de n√∫meros:</strong>
                    la herramienta apoya la investigaci√≥n en √°reas como la optimizaci√≥n combinatoria, el dise√±o de
                    algoritmos y la
                    teor√≠a de grafos, integrando conceptos algebraicos con aplicaciones computacionales para el an√°lisis
                    de
                    estructuras complejas.
                </p>
            </div>
        </section>

        <section id="sH">
            <h2>Semigrupos num√©ricos de g√©nero fijo</h2>
            <label for="inputNumeros">Introduce el g√©nero:</label>
            <input type="number" id="inputNumeros" min="0" placeholder="Ej. 3" required>
            <button onclick="calcular()">Calcular</button>
            <button onclick="vaciarResultados()">Vaciar</button>
        </section>

        <section id="sH">
            <h2>Semigrupos num√©ricos que tengan ese g√©nero:</h2>
            <div id="generoFijo"></div>
            <h3>Tiempo de c√°lculo:</h3>
            <div id="tiempoCalculo"></div>
        </section>
    </main>

    <footer id="f1"><a id="e1" href="documentocontacto.html">Documento de
            contacto</a>---------------------------------------------------------------------
        <a id="e1" href="documentacion.pdf">documentacion.pdf</a>
    </footer>
</body>

</html>